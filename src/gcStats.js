'use strict';

const gc = require('gc-stats')();
const EventEmitter = require('events');

function gctypeToString(gctype) {
  switch (gctype) {
    case 1:
      return 'Scavenge';
    case 2:
      return 'MarkSweepCompact';
    case 4:
      return 'IncrementalMarking';
    case 8:
      return 'ProcessWeakCallbacks';
    case 15:
      return 'All';
    default:
      return 'Unknown';
  }
}

class GcStatsEmitter extends EventEmitter {
  constructor(gc, pauseTimeMillisThreshold, reclaimedHeapBytesThreshold) {
    super();

    gc.on('stats', stats => {
      this.maybeEmitStats(stats);
    });

    this.pauseTimeMillisThreshold = pauseTimeMillisThreshold;
    this.reclaimedHeapBytesThreshold = reclaimedHeapBytesThreshold;
  }

  /**
   * Apply thresholds and black-hole stats that do not satisfy them; otherwise re-emit.
   *
   * Shape of the base stats object:
   * {
   *   pause: 433034,
   *   pauseMS: 0,
   *   gctype: 1,
   *   before: {
   *     totalHeapSize: 18635008,
   *     totalHeapExecutableSize: 4194304,
   *     usedHeapSize: 12222496,
   *     heapSizeLimit: 1535115264
   *   },
   *   after: {
   *     totalHeapSize: 18635008,
   *     totalHeapExecutableSize: 4194304,
   *     usedHeapSize: 8116600,
   *     heapSizeLimit: 1535115264
   *   },
   *   diff: {
   *     totalHeapSize: 0,
   *     totalHeapExecutableSize: 0,
   *     usedHeapSize: -4105896,
   *     heapSizeLimit: 0
   *   }
   * }
   *
   * @param stats A `stats` event argument as generated by the `gc-stats` lib.
   */
  maybeEmitStats(stats) {
    // Re-emit if any threshold is exceeded.
    let shouldRemit = false;
    if (stats.pauseMS >= this.pauseTimeMillisThreshold) {
      shouldRemit = true;
    }
    if (Math.abs(stats.diff.usedHeapSize) >= this.reclaimedHeapBytesThreshold) {
      shouldRemit = true;
    }

    if (shouldRemit) {
      stats.gcdesc = gctypeToString(stats.gctype);
      this.emit('stats', stats);
    }
  }
}

// Initialize thresholds with reasonable defaults and apply process environment overrides.
let pauseTimeMillisThreshold = 50;
if (process.env.GC_STATS_PAUSE_MILLIS_THRESHOLD) {
  let override = Number.parseInt(process.env.GC_STATS_PAUSE_MILLIS_THRESHOLD, 10);
  if (!Number.isNaN(override)) {
    pauseTimeMillisThreshold = override;
  }
}

let reclaimedHeapBytesThreshold = 50000;
if (process.env.GC_STATS_RECLAIMED_HEAP_BYTES_THRESHOLD) {
  let override = Number.parseInt(process.env.GC_STATS_RECLAIMED_HEAP_BYTES_THRESHOLD, 10);
  if (!Number.isNaN(override)) {
    reclaimedHeapBytesThreshold = override;
  }
}

module.exports = new GcStatsEmitter(gc, pauseTimeMillisThreshold, reclaimedHeapBytesThreshold);